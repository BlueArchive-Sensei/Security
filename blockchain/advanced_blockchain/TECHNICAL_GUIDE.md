# åŒºå—é“¾ç³»ç»ŸæŠ€æœ¯æŒ‡å—

## ğŸ“š æŠ€æœ¯æ¶æ„æ¦‚è¿°

æœ¬åŒºå—é“¾ç³»ç»Ÿé‡‡ç”¨æ¨¡å—åŒ–æ¶æ„è®¾è®¡ï¼Œå®ç°äº†ç°ä»£åŒºå—é“¾çš„æ ¸å¿ƒæŠ€æœ¯æ ˆã€‚

### ğŸ—ï¸ ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨å±‚ (Application Layer)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  REST API    â”‚  WebSocket    â”‚  Webç•Œé¢    â”‚  CLIå·¥å…·      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ç½‘ç»œå±‚ (Network Layer)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  P2Pé€šä¿¡     â”‚  èŠ‚ç‚¹å‘ç°     â”‚  æ•°æ®åŒæ­¥    â”‚  å¹¿æ’­æœºåˆ¶      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    å…±è¯†å±‚ (Consensus Layer)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å·¥ä½œé‡è¯æ˜   â”‚  éš¾åº¦è°ƒæ•´     â”‚  åˆ†å‰å¤„ç†    â”‚  é“¾éªŒè¯       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ•°æ®å±‚ (Data Layer)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŒºå—ç»“æ„    â”‚  äº¤æ˜“æ±       â”‚  Merkleæ ‘   â”‚  æ•°å­—ç­¾å      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   å­˜å‚¨å±‚ (Storage Layer)                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  æ–‡ä»¶å­˜å‚¨    â”‚  å†…å­˜ç¼“å­˜     â”‚  çŠ¶æ€ç®¡ç†    â”‚  æ•°æ®åºåˆ—åŒ–    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ” å¯†ç å­¦æŠ€æœ¯è¯¦è§£

### 1. ECDSAæ•°å­—ç­¾å

```python
# ç­¾åæµç¨‹
def sign_transaction(transaction_data, private_key):
    """
    1. è®¡ç®—äº¤æ˜“æ•°æ®çš„SHA-256å“ˆå¸Œ
    2. ä½¿ç”¨ç§é’¥å¯¹å“ˆå¸Œè¿›è¡ŒECDSAç­¾å
    3. è¿”å›ç­¾åå’Œå…¬é’¥
    """
    data_hash = hashlib.sha256(transaction_data.encode()).digest()
    signature = private_key.sign(data_hash)
    return signature, private_key.get_verifying_key()

# éªŒè¯æµç¨‹
def verify_signature(transaction_data, signature, public_key):
    """
    1. è®¡ç®—äº¤æ˜“æ•°æ®çš„SHA-256å“ˆå¸Œ
    2. ä½¿ç”¨å…¬é’¥éªŒè¯ç­¾å
    3. è¿”å›éªŒè¯ç»“æœ
    """
    data_hash = hashlib.sha256(transaction_data.encode()).digest()
    return public_key.verify(signature, data_hash)
```

### 2. åœ°å€ç”Ÿæˆç®—æ³•

```python
def generate_address(public_key):
    """
    æ¯”ç‰¹å¸é£æ ¼çš„åœ°å€ç”Ÿæˆ:
    1. SHA-256å“ˆå¸Œå…¬é’¥
    2. RIPEMD-160å“ˆå¸Œç»“æœ
    3. æ·»åŠ ç‰ˆæœ¬å­—èŠ‚
    4. è®¡ç®—æ ¡éªŒå’Œ
    5. Base58ç¼–ç 
    """
    sha256_hash = hashlib.sha256(public_key).digest()
    ripemd160_hash = hashlib.new('ripemd160', sha256_hash).digest()
    versioned = b'\x00' + ripemd160_hash
    checksum = hashlib.sha256(hashlib.sha256(versioned).digest()).digest()[:4]
    return base58.b58encode(versioned + checksum).decode()
```

## ğŸŒ² Merkleæ ‘æŠ€æœ¯å®ç°

### æ•°æ®ç»“æ„

```python
class MerkleTree:
    """
    Merkleæ ‘æä¾›é«˜æ•ˆçš„æ•°æ®å®Œæ•´æ€§éªŒè¯
    
    ç‰¹æ€§:
    - O(log n) éªŒè¯å¤æ‚åº¦
    - æ”¯æŒSPV (ç®€åŒ–æ”¯ä»˜éªŒè¯)
    - é˜²ç¯¡æ”¹æ£€æµ‹
    """
    
    def build_tree(self, transactions):
        """
        æ„å»ºè¿‡ç¨‹:
        1. è®¡ç®—å¶å­èŠ‚ç‚¹å“ˆå¸Œ
        2. ä¸¤ä¸¤ç»„åˆè®¡ç®—çˆ¶èŠ‚ç‚¹
        3. é‡å¤ç›´åˆ°å¾—åˆ°æ ¹å“ˆå¸Œ
        """
        current_level = [self.hash(tx) for tx in transactions]
        
        while len(current_level) > 1:
            next_level = []
            for i in range(0, len(current_level), 2):
                left = current_level[i]
                right = current_level[i+1] if i+1 < len(current_level) else left
                parent = self.hash(left + right)
                next_level.append(parent)
            current_level = next_level
            
        return current_level[0] if current_level else None
```

### SPVéªŒè¯åŸç†

```python
def verify_transaction_inclusion(transaction, merkle_path, merkle_root):
    """
    SPVéªŒè¯å…è®¸è½»å®¢æˆ·ç«¯éªŒè¯äº¤æ˜“è€Œæ— éœ€ä¸‹è½½å®Œæ•´åŒºå—
    
    éªŒè¯æ­¥éª¤:
    1. è®¡ç®—äº¤æ˜“å“ˆå¸Œ
    2. æ²¿ç€Merkleè·¯å¾„å‘ä¸Šè®¡ç®—
    3. ä¸Merkleæ ¹æ¯”è¾ƒ
    """
    current_hash = hash(transaction)
    
    for step in merkle_path:
        if step['position'] == 'right':
            current_hash = hash(current_hash + step['hash'])
        else:
            current_hash = hash(step['hash'] + current_hash)
    
    return current_hash == merkle_root
```

## âš¡ å…±è¯†æœºåˆ¶è¯¦è§£

### å·¥ä½œé‡è¯æ˜ (Proof of Work)

```python
class ProofOfWork:
    """
    å·¥ä½œé‡è¯æ˜ç¡®ä¿ç½‘ç»œå®‰å…¨å’Œå»ä¸­å¿ƒåŒ–
    
    åŸç†:
    - çŸ¿å·¥å¯»æ‰¾æ»¡è¶³éš¾åº¦æ¡ä»¶çš„nonceå€¼
    - å“ˆå¸Œå€¼å¿…é¡»ä»¥æŒ‡å®šæ•°é‡çš„0å¼€å¤´
    - éš¾åº¦åŠ¨æ€è°ƒæ•´ç»´æŒå‡ºå—æ—¶é—´
    """
    
    def mine_block(self, block, difficulty):
        """
        æŒ–çŸ¿è¿‡ç¨‹:
        1. è®¾ç½®ç›®æ ‡å€¼ (difficultyä¸ª0)
        2. å°è¯•ä¸åŒnonceå€¼
        3. è®¡ç®—åŒºå—å“ˆå¸Œ
        4. æ£€æŸ¥æ˜¯å¦æ»¡è¶³éš¾åº¦è¦æ±‚
        """
        target = "0" * difficulty
        nonce = 0
        
        while True:
            block.nonce = nonce
            block_hash = self.calculate_hash(block)
            
            if block_hash[:difficulty] == target:
                block.hash = block_hash
                return nonce
                
            nonce += 1
```

### éš¾åº¦è°ƒæ•´ç®—æ³•

```python
def adjust_difficulty(self, blockchain):
    """
    éš¾åº¦è°ƒæ•´ç»´æŒç¨³å®šçš„å‡ºå—æ—¶é—´
    
    è°ƒæ•´ç­–ç•¥:
    - å‡ºå—æ—¶é—´ < ç›®æ ‡æ—¶é—´/2: å¢åŠ éš¾åº¦
    - å‡ºå—æ—¶é—´ > ç›®æ ‡æ—¶é—´*2: é™ä½éš¾åº¦
    - å¦åˆ™ä¿æŒå½“å‰éš¾åº¦
    """
    if len(blockchain.chain) < 2:
        return blockchain.difficulty
    
    latest_block = blockchain.get_latest_block()
    previous_block = blockchain.chain[-2]
    
    time_taken = latest_block.timestamp - previous_block.timestamp
    target_time = 10  # ç›®æ ‡10ç§’
    
    if time_taken < target_time / 2:
        return blockchain.difficulty + 1
    elif time_taken > target_time * 2:
        return max(1, blockchain.difficulty - 1)
    else:
        return blockchain.difficulty
```

## ğŸŒ P2Pç½‘ç»œæ¶æ„

### èŠ‚ç‚¹å‘ç°æœºåˆ¶

```python
class NodeDiscovery:
    """
    P2Pç½‘ç»œä¸­çš„èŠ‚ç‚¹å‘ç°å’Œè¿æ¥ç®¡ç†
    
    å‘ç°æ–¹å¼:
    1. ç¡¬ç¼–ç ç§å­èŠ‚ç‚¹
    2. DNSç§å­èŠ‚ç‚¹
    3. å·²çŸ¥èŠ‚ç‚¹ä¼ æ’­
    4. æœ¬åœ°ç½‘ç»œæ‰«æ
    """
    
    def discover_peers(self):
        """
        èŠ‚ç‚¹å‘ç°æµç¨‹:
        1. è¿æ¥åˆ°ç§å­èŠ‚ç‚¹
        2. è¯·æ±‚èŠ‚ç‚¹åˆ—è¡¨
        3. æµ‹è¯•æ–°èŠ‚ç‚¹è¿æ¥
        4. ç»´æŠ¤æ´»è·ƒè¿æ¥æ± 
        """
        for seed in self.seed_nodes:
            try:
                peer_list = self.request_peers(seed)
                for peer in peer_list:
                    if self.test_connection(peer):
                        self.add_peer(peer)
            except Exception as e:
                logger.warning(f"ç§å­èŠ‚ç‚¹ {seed} è¿æ¥å¤±è´¥: {e}")
```

### æ•°æ®åŒæ­¥åè®®

```python
class BlockchainSync:
    """
    åŒºå—é“¾åŒæ­¥ç¡®ä¿ç½‘ç»œä¸€è‡´æ€§
    
    åŒæ­¥ç­–ç•¥:
    1. æ¯”è¾ƒé“¾é•¿åº¦
    2. ä¸‹è½½ç¼ºå¤±åŒºå—
    3. éªŒè¯åŒºå—æœ‰æ•ˆæ€§
    4. åº”ç”¨æœ€é•¿æœ‰æ•ˆé“¾
    """
    
    def sync_blockchain(self):
        """
        åŒæ­¥æµç¨‹:
        1. å¹¿æ’­é“¾çŠ¶æ€
        2. æ¥æ”¶å…¶ä»–èŠ‚ç‚¹çŠ¶æ€
        3. è¯†åˆ«æœ€é•¿æœ‰æ•ˆé“¾
        4. ä¸‹è½½å¹¶éªŒè¯åŒºå—
        5. æ›´æ–°æœ¬åœ°é“¾
        """
        local_height = len(self.blockchain.chain)
        best_peer = None
        best_height = local_height
        
        for peer in self.peers:
            peer_height = self.get_peer_height(peer)
            if peer_height > best_height:
                best_peer = peer
                best_height = peer_height
        
        if best_peer:
            self.download_blocks(best_peer, local_height, best_height)
```

## ğŸ’¼ äº¤æ˜“æ± ç®¡ç†

### ä¼˜å…ˆçº§ç®—æ³•

```python
class TransactionPool:
    """
    äº¤æ˜“æ± ç®¡ç†å¾…å¤„ç†äº¤æ˜“
    
    ä¼˜å…ˆçº§å› ç´ :
    1. æ‰‹ç»­è´¹ç‡ (fee/size)
    2. ç­‰å¾…æ—¶é—´
    3. äº¤æ˜“ç±»å‹
    4. ç½‘ç»œæ‹¥å µæƒ…å†µ
    """
    
    def calculate_priority(self, transaction):
        """
        ä¼˜å…ˆçº§è®¡ç®—:
        priority = fee_rate * time_factor * type_factor
        """
        fee_rate = transaction.fee / transaction.size
        time_factor = min(2.0, time.time() - transaction.timestamp) / 3600
        type_factor = 1.5 if transaction.is_system else 1.0
        
        return fee_rate * (1 + time_factor) * type_factor
    
    def select_transactions(self, max_count, max_size):
        """
        äº¤æ˜“é€‰æ‹©ç­–ç•¥:
        1. æŒ‰ä¼˜å…ˆçº§æ’åº
        2. è´ªå¿ƒé€‰æ‹©é«˜ä»·å€¼äº¤æ˜“
        3. è€ƒè™‘åŒºå—å¤§å°é™åˆ¶
        4. é¿å…åŒé‡æ”¯ä»˜
        """
        sorted_txs = sorted(
            self.pending_transactions,
            key=self.calculate_priority,
            reverse=True
        )
        
        selected = []
        total_size = 0
        
        for tx in sorted_txs:
            if (len(selected) < max_count and 
                total_size + tx.size <= max_size and
                not self.has_conflict(tx, selected)):
                selected.append(tx)
                total_size += tx.size
        
        return selected
```

## ğŸ”„ åˆ†å‰å¤„ç†æœºåˆ¶

### åˆ†å‰æ£€æµ‹

```python
class ForkDetector:
    """
    åˆ†å‰æ£€æµ‹å’Œå¤„ç†ç¡®ä¿ç½‘ç»œä¸€è‡´æ€§
    
    åˆ†å‰ç±»å‹:
    1. è½¯åˆ†å‰: è§„åˆ™æ”¶ç´§ï¼Œå‘åå…¼å®¹
    2. ç¡¬åˆ†å‰: è§„åˆ™æ”¾æ¾ï¼Œä¸å…¼å®¹
    3. å­¤å„¿åŒºå—: ä¸´æ—¶åˆ†å‰
    """
    
    def detect_fork(self, new_block):
        """
        åˆ†å‰æ£€æµ‹:
        1. æ£€æŸ¥çˆ¶åŒºå—å“ˆå¸Œ
        2. éªŒè¯åŒºå—æœ‰æ•ˆæ€§
        3. æ¯”è¾ƒé“¾æƒé‡
        4. å†³å®šæ˜¯å¦åˆ‡æ¢
        """
        if new_block.previous_hash == self.get_latest_hash():
            # æ­£å¸¸æ·»åŠ 
            return 'append'
        elif self.is_known_block(new_block.previous_hash):
            # æ£€æµ‹åˆ°åˆ†å‰
            return 'fork'
        else:
            # å­¤å„¿åŒºå—
            return 'orphan'
```

### é“¾é‡ç»„ç®—æ³•

```python
def reorganize_chain(self, alternative_chain):
    """
    é“¾é‡ç»„è¿‡ç¨‹:
    1. æ‰¾åˆ°åˆ†å‰ç‚¹
    2. å›æ»šäº¤æ˜“åˆ°åˆ†å‰ç‚¹
    3. åº”ç”¨æ–°é“¾çš„äº¤æ˜“
    4. æ›´æ–°çŠ¶æ€å’Œä½™é¢
    """
    fork_point = self.find_fork_point(alternative_chain)
    
    # å›æ»šäº¤æ˜“
    reverted_txs = []
    for i in range(len(self.chain) - 1, fork_point, -1):
        reverted_txs.extend(self.chain[i].transactions)
        
    # åº”ç”¨æ–°é“¾
    self.chain = self.chain[:fork_point + 1] + alternative_chain[fork_point + 1:]
    
    # é‡æ–°å¤„ç†äº¤æ˜“
    self.reprocess_transactions(reverted_txs)
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### å†…å­˜ç®¡ç†

```python
class MemoryOptimizer:
    """
    å†…å­˜ä¼˜åŒ–å‡å°‘èµ„æºæ¶ˆè€—
    
    ç­–ç•¥:
    1. åŒºå—æ•°æ®å‹ç¼©
    2. LRUç¼“å­˜æœºåˆ¶
    3. å¢é‡çŠ¶æ€æ›´æ–°
    4. åƒåœ¾å›æ”¶ä¼˜åŒ–
    """
    
    def optimize_block_storage(self, block):
        """
        åŒºå—å­˜å‚¨ä¼˜åŒ–:
        1. å‹ç¼©äº¤æ˜“æ•°æ®
        2. å¢é‡å­˜å‚¨å˜åŒ–
        3. å»¶è¿ŸåŠ è½½æœºåˆ¶
        """
        compressed_data = zlib.compress(block.serialize())
        return {
            'header': block.get_header(),
            'compressed_transactions': compressed_data,
            'merkle_root': block.merkle_root
        }
```

### ç½‘ç»œä¼˜åŒ–

```python
class NetworkOptimizer:
    """
    ç½‘ç»œé€šä¿¡ä¼˜åŒ–
    
    æŠ€æœ¯:
    1. è¿æ¥æ± ç®¡ç†
    2. æ•°æ®å‹ç¼©
    3. æ‰¹é‡ä¼ è¾“
    4. æ™ºèƒ½è·¯ç”±
    """
    
    def optimize_broadcast(self, data, peers):
        """
        å¹¿æ’­ä¼˜åŒ–:
        1. é€‰æ‹©æœ€ä½³è·¯å¾„
        2. å‹ç¼©æ•°æ®
        3. å¹¶è¡Œå‘é€
        4. é‡è¯•æœºåˆ¶
        """
        compressed_data = self.compress(data)
        
        for peer in peers:
            self.send_async(peer, compressed_data)
```

## ğŸ›¡ï¸ å®‰å…¨é˜²æŠ¤æœºåˆ¶

### æ”»å‡»é˜²æŠ¤

```python
class SecurityManager:
    """
    å®‰å…¨é˜²æŠ¤æŠµå¾¡å„ç§æ”»å‡»
    
    é˜²æŠ¤ç±»å‹:
    1. 51% æ”»å‡»é˜²æŠ¤
    2. åŒé‡æ”¯ä»˜é˜²æŠ¤
    3. DDoSæ”»å‡»é˜²æŠ¤
    4. Eclipseæ”»å‡»é˜²æŠ¤
    """
    
    def detect_51_attack(self):
        """
        51%æ”»å‡»æ£€æµ‹:
        1. ç›‘æ§ç®—åŠ›åˆ†å¸ƒ
        2. æ£€æµ‹å¼‚å¸¸å‡ºå—
        3. éªŒè¯é“¾æƒé‡
        """
        recent_blocks = self.get_recent_blocks(100)
        miner_distribution = self.analyze_miners(recent_blocks)
        
        for miner, count in miner_distribution.items():
            if count / len(recent_blocks) > 0.51:
                self.alert_51_attack(miner)
    
    def prevent_double_spending(self, transaction):
        """
        åŒé‡æ”¯ä»˜é˜²æŠ¤:
        1. æ£€æŸ¥UTXOçŠ¶æ€
        2. éªŒè¯äº¤æ˜“å†å²
        3. ç¡®è®¤äº¤æ˜“å”¯ä¸€æ€§
        """
        utxos = self.get_utxos(transaction.sender)
        return self.verify_utxo_availability(transaction, utxos)
```

## ğŸ“ˆ ç›‘æ§å’Œè¯Šæ–­

### æ€§èƒ½ç›‘æ§

```python
class PerformanceMonitor:
    """
    æ€§èƒ½ç›‘æ§æä¾›ç³»ç»Ÿæ´å¯Ÿ
    
    æŒ‡æ ‡:
    1. TPS (æ¯ç§’äº¤æ˜“æ•°)
    2. åŒºå—æ—¶é—´
    3. å†…å­˜ä½¿ç”¨
    4. ç½‘ç»œå»¶è¿Ÿ
    """
    
    def calculate_tps(self, time_window=60):
        """
        TPSè®¡ç®—:
        1. ç»Ÿè®¡æ—¶é—´çª—å£å†…äº¤æ˜“æ•°
        2. è®¡ç®—å¹³å‡TPS
        3. è®°å½•å³°å€¼TPS
        """
        recent_blocks = self.get_blocks_in_timeframe(time_window)
        total_transactions = sum(len(block.transactions) for block in recent_blocks)
        return total_transactions / time_window
```

## ğŸ”§ æ‰©å±•æ¥å£

### APIæ‰©å±•

```python
class APIExtension:
    """
    APIæ‰©å±•æ”¯æŒè‡ªå®šä¹‰åŠŸèƒ½
    
    æ‰©å±•ç‚¹:
    1. è‡ªå®šä¹‰è·¯ç”±
    2. ä¸­é—´ä»¶
    3. è®¤è¯æœºåˆ¶
    4. æ•°æ®æ ¼å¼
    """
    
    def register_custom_endpoint(self, path, handler):
        """
        æ³¨å†Œè‡ªå®šä¹‰APIç«¯ç‚¹
        """
        self.app.route(f'/api/v1/custom/{path}')(handler)
```

---

**ğŸ¯ è¿™ä»½æŠ€æœ¯æŒ‡å—ä¸ºæ·±å…¥ç†è§£å’Œæ‰©å±•åŒºå—é“¾ç³»ç»Ÿæä¾›äº†å®Œæ•´çš„æŠ€æœ¯åŸºç¡€ï¼** 